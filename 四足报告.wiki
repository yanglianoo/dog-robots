= 四足机器人仿真设计文档[[File:C:\Users\~~\Desktop\微信图片_20210419135158.jpg|fig:]] =

'''联系人'''：阳炼 '''QQ'''：330070781 '''微信'''：Y13699648817 

'''前言'''：此文档仅供粤港机器人学院内部交流学习所用，有什么问题可以私聊我咱们一起讨论交流，切勿外传！

'''四足学习流程'''：

①：Vrep仿真软件学习使用，软件使用教程可以参考我下面给出的视屏教程地址。仿真软件可支持我们对机器人进行运动学和动力学的仿真以及算法的快速开发。常见的仿真软件包括Webots,Gazebo,V-rep,Adams以及Python的bullet环境，具体软件学习参照个人爱好，我比较推荐V-rep和Webots。

②：四足机器人运动学，不同的机器人构型运动学解算不同，需要我们掌握数学解算的能力。包括四足机器人的正逆运动学，站立姿态解算，步态调整时序，足端轨迹规划。

③：四足机器人动力学，包括VMC三通道解耦框架,VSMC算法，力控相对于位控拥有更多的好处，具体的算法推导与实现可看后面详述。

= 一、V-rep软件使用 =

1.软件下载

官网地址：https://coppeliarobotics.com/downloads

百度云：https://pan.baidu.com/s/1aUwWWCFtOd8uim4VzC9UHw 提取码：zuuc 

Tips:版本选择为v4.0及以上，v4.0以下的版本许多功能不是很好用。

2.软件使用教程

教程地址：https://class.guyuehome.com/detail/p_605af87be4b007b4183a42e7/6

教程为我所录制，需要收费😆，由于和古月居签了合同，所以视频不能私自外传，见谅。教程涵盖了vrep的使用方法以及四足机器人的运动学部分，其中有许多软件使用的小细节我都已经在视频中详细的解释了，在实际学习过程中如有遇到什么BUG可与我联系。

= 二、运动学部分 =

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210417140958259.png|frame|none|alt=|caption image-20210417140958259]]

以12自由度串联型四足机器人为例，每条腿三个自由度。

== 1：运动学逆解 ==

给定一个所需的P，P为足端轨迹点，坐标为(x，y，z)相对于机器人肩关节，给定机器人各个模型杆件长度参数，求出每个关节旋转的对应的角度，即为逆运动学解算的过程。

正运动学即为已知每个关节转动角度，求出足端点相对于肩关节的位置点P。

[[File:/C:/Users/~~/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png|frame|none|alt=|caption img]]

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416220051592.png|frame|none|alt=|caption image-20210416220051592]]

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416221308857.png|frame|none|alt=|caption image-20210416221308857]]

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416221336628.png|frame|none|alt=|caption image-20210416221336628]]

<source lang="python">def xyztoang(x,y,z,h,hu,hl):
 #Some sqrt’s can be optimized out
 dyz=np.sqrt(y**2+z**2)
 lyz=np.sqrt(dyz**2-h**2)
 gamma_yz=-np.arctan(y/z)
 gamma_h_offset=-np.arctan(h/lyz)
 gamma=gamma_yz-gamma_h_offset
 #
 lxzp=np.sqrt(lyz**2+x**2)
 n=(lxzp**2-hl**2-hu**2)/(2*hu)
 beta=-np.arccos(n/hl)
 #
 alfa_xzp=-np.arctan(x/lyz)
 alfa_off=np.arccos((hu+n)/lxzp)
 alfa=alfa_xzp+alfa_off
 #
 return [alfa,beta,gamma]</source>
== 2：站立姿态解算 ==

教程地址：https://zhuanlan.zhihu.com/p/64321561

①：身体姿态表示

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416221749339.png|frame|none|alt=|caption ]]

②：单腿末端位置向量求解

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416222009697.png|frame|none|alt=|caption ]]

<source lang="matlab">function [rb_x,rb_y,rb_z,rf_x,rf_y,rf_z,lb_x,lb_y,lb_z,lf_x,lf_y,lf_z] = pose_control(row,pitch,yaw,pos_x,pos_y,pos_z)
b=0.4;
l=0.8;
w=0.7;
h=0.732;
R=row*pi/180   ;
P=pitch*pi/180 ;
Y=yaw*pi/180   ;
pos=[pos_x,pos_y,pos_z]';
rotx=([[ 1,        0,         0      ]
       [ 0,        cos(R),   -sin(R) ]
       [ 0,        sin(R),    cos(R) ]]);
roty=([[ cos(P),   0,        -sin(P) ]
       [ 0,        1,         0      ]
       [ sin(P),   0,         cos(P) ]]);
rotz=([[ cos(Y),  -sin(Y),    0      ]
       [ sin(Y),   cos(Y),    0      ]
       [ 0,        0,         1      ]]);
rot_mat = rotx * roty * rotz;
%结构参数
  body_struct = ([[ l / 2,  -b / 2,  h]     
                 [  l / 2, b / 2,   h]     
                 [ -l / 2,  b / 2,    h]     
                 [ -l / 2, -b / 2,   h]])'; 
             
 footpoint_struct = ([[ l/2,   -w/2,  0]
                     [  l/2,   w/2,  0]
                     [  -l/2,    w/2,  0]
                     [  -l/2,    -w/2,  0]])';
leg_pose = zeros(3, 4);
for i= 1:4
    leg_pose(:,i) =  pos + rot_mat * body_struct(:, i) - footpoint_struct(:, i);
end
 rb_x = (leg_pose(1, 1));rb_y = -(leg_pose(2, 1));rb_z = -(leg_pose(3, 1));
 rf_x = (leg_pose(1, 2));rf_y = (leg_pose(2, 2));rf_z = -(leg_pose(3, 2));
 lb_x = (leg_pose(1, 3));lb_y = (leg_pose(2, 3));lb_z = -(leg_pose(3, 3));
 lf_x = (leg_pose(1, 4));lf_y = -(leg_pose(2, 4));lf_z = -(leg_pose(3, 4));
end</source>
得到了四足机器人姿态的解算关系，我们就可以对四足机器人的姿态进行控制，常见应用场景比如四足机器人在晃动平台上的自平衡调整，四足机器人的身体扭动等等。

== 3：足端轨迹规划 ==

足端轨迹规划包括摆动相和支撑相的足端轨迹规划，这里只考虑摆动相的轨迹。

①：摆线，最常见的足端轨迹规划方式，适用于较为平坦的地面。

公式：[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416222357256.png|fig:]]

<source lang="matlab">clc;
clear;
Ts=1;    %周期
xs=-0.1;    %起点x位置
xf=0.1;     %终点x位置
zs=-0.582;   %z起点位置
h=0.1;      %抬腿高度
x=[];
z=[];
for t=0:0.01:Ts
    sigma=2*pi*t/(Ts);
    xep=(xf-xs)*((sigma-sin(sigma))/(2*pi))+xs;
    zep=h*(1-cos(sigma))/2+zs;
    x=[x,xep];
    z=[z,zep];
end
plot(x,z,'r','LineWidth',3)</source>
②：三次B样条曲线，适用于各种情况，自主调整。具体算法推导过程可参考何俊杰与李卓辉的PR报告书，这里不做赘述，贴出测试代码。

<source lang="matlab">C=[-2 -2 -2 -1 0 1 2 2 2  %给定目标控制点
   -1 -1 -1 0 0 0 1 1 1];
v1=[0;0];
v2=[0;0];
L=254/2;
%L=0;
NC=length(C); %原始控制点数
RC=[C(:,1)-v1*L,C(:,1),C(:,1)+v1*L,C(:,2:NC-1),C(:,NC)-v2*L,C(:,NC),C(:,NC)+v2*L];
N=length(RC);
t=0:0.01:1;      %归一化时间
s=0:0.01:1;
k=0:0.01:1;
f1s=(1-t).^3/6;  %四个位置样条函数
f2s=(3*t.^3-6*t.^2+4)/6;
f3s=(-3*t.^3+3*t.^2+3*t+1)/6;
f4s=t.^3/6;      
%四个速度样条函数
v1s=-(1-t).^2/2;
v2s=3*t.^2/2-2*t;
v3s=-3*t.^2/2+t+0.5;
v4s=t.^2/2;
%加速度曲线
a1s=1-t;
a2s=3*t-2;
a3s=1-3*t;
a4s=t;
figure(1);
mycolor='mbch';
plot(RC(1,:),RC(2,:),'r*');
hold on;
for i=1:N-3
    P=RC(:,i)*f1s+RC(:,i+1)*f2s+RC(:,i+2)*f3s+RC(:,i+3)*f4s;
    %disp(P);
    plot(P(1,:),P(2,:),mycolor(mod(i,3)+1));
end
title('路径规划位置曲线');
grid on;
hold off;
figure(2);
hold on;
for i=1:N-3
    P=RC(:,i)*f1s+RC(:,i+1)*f2s+RC(:,i+2)*f3s+RC(:,i+3)*f4s;
    V=RC(:,i)*v1s+RC(:,i+1)*v2s+RC(:,i+2)*v3s+RC(:,i+3)*v4s;
    %plot(P(2,:),V(2,:),mycolor(mod(i,3)+1));
   % plot(s,V(2,:)*20,mycolor(mod(i,3)+1));
   plot(s/4,V(2,:)*4,mycolor(mod(i,3)+1));
   % plot(s,sqrt(V(2,:)^2+V(1,:)^2),mycolor(mod(i,3)+1));
    %pos=atan(V(2,:)/V(1,:));
     % plot(s,pos(1,:)*180/2/pi,mycolor(mod(i,3)+1));
    s=s+1;
end
title('路径规划速度曲线');
grid on;
hold off;
figure(3);
hold on;
for i=1:N-3
    P=RC(:,i)*f1s+RC(:,i+1)*f2s+RC(:,i+2)*f3s+RC(:,i+3)*f4s;
   % V=RC(:,i)*v1s+RC(:,i+1)*v2s+RC(:,i+2)*v3s+RC(:,i+3)*v4s;
    A=RC(:,i)*a1s+RC(:,i+1)*a2s+RC(:,i+2)*a3s+RC(:,i+3)*a4s;
    plot(k,A(2,:),mycolor(mod(i,3)+1));
   % plot(k,A(2,:)*20,mycolor(mod(i,3)+1));
    k=k+1;
end
title('路径规划加速度曲线');
hold off;</source>
除了以上列出的两种足端轨迹规划方式，在实际应用中还有其他更复杂、更完美、效果更好的轨迹规划方式。

== 4：仿真赛中四足机器人 ==

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416224233183.png|frame|none|alt=|caption image-20210416224233183]]

仿真要求为三种基础步态和过排管与跨高栏的物种运行模式，基础步态包括缓步走，对角小跑，奔跑三种。

=== 4.1、三种步态的实现 ===

三种步态的摆动相轨迹都是采用摆线，支撑相轨迹为平行于机器人身体的直线，切换不同腿部动作时序即可实现三种步态，未对偏航角做闭环处理。有几个需要注意的点：

①：trot步态仿真时，一个步态周期需要稍微调短一点，因为trot步态本质上是一个动态平衡的过程。需要我们减小步态周期来实现这样一个动态平衡的效果

②：逆解公式推导，与前面的构型计算方式不同，需要重新构建，数学推导如下。

<source lang="matlab">function [gamma,alfa,beta] = xyz_f(x,y,z) %前两条腿的解算方式
h=0.12;
hu=0.26;
hl=0.33;
h2=-0.08;  %其中前两条腿与后两条腿相对坐标不一样 f:-0.08 b：0.08 单位：m ，其中后面的角度变换也有符号变换
dyz=sqrt(y.^2+z.^2);
lyz=sqrt(dyz.^2-h.^2);
gamma_yz=-atan(y/z);
gamma_h_offset=-atan(h./lyz);
gamma=gamma_yz-gamma_h_offset;
lxzp=sqrt(lyz.^2+(x+h2).^2);
cos_beta=(lxzp.^2-hu.^2-hl.^2-h2.^2)/(2*hu*sqrt(hl.^2+h2.^2));
beta_base=acos(cos_beta);
beta_off=atan(h2/hl);
beta=beta_off+beta_base;
alfa_xzp=atan((x+h2)/lyz);
cos_alfa=(hu.^2+lxzp.^2-hl.^2-h2.^2)/(2*hu*lxzp);
alfa_off=acos(cos_alfa);
alfa=alfa_xzp+alfa_off;
%输出角度为弧度
end</source>
③：仿真软件中时间的获取是在软件脚本中获取时间，将此时间值定义为可发送的浮点数据值，采用向Matlab客户端发送此浮点数据来获取仿真环境真实时间。

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210417140825861.png|frame|none|alt=|caption ]]

=== 4.2、过排管和跨高栏 ===

过高栏采用单次跳跃方式实现，运用运动学实现四足机器人的跳跃实质就是为四足机器人规划一条能使四足机器人跳跃的轨迹，例如下面的一条足端轨迹就能实现四足机器人的跳跃

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210416225525663.png|frame|none|alt=|caption image-20210416225525663]]

过排管可以采取缓步踏过去，但由于我未对机器人做姿态闭环控制，实际测试时采用这种方式会使机器人在过排管时会打滑，严重时甚至会发生侧翻。因此我最终采用的方案为连续跳跃。

= 三、虚拟模型控制方法 =

与上面的位置伺服控制不同，虚拟模型控制方法我们给定的最后输出量为关节力矩，通过构建四足机器人力学模型来达到更稳定精确的控制效果。

== 3.1 VMC算法('''Virtual Model Control''') ==

=== 3.1.1 算法基本原理 ===

 VMC 是一种直觉控制方式，其核心思想是利用假想的虚拟构件(如弹簧、阻尼器、轴承等等)连接机器人内部作用点，或者连接作用点与外部环境，产生相应的虚拟力来“驱使”机器人实现期望的运动。这些虚拟力通过 Jacobian 矩阵计算得到期望的关节力矩，作为关节控制的输入，驱动机器人运动以产生和虚拟构件一样的作用效果。VMC 的应用关键在于两点：一是在每个需要控制的自由度上构造恰当的虚拟构件以产生合适的虚拟力；二是在不同的相位状态利用相应的 Jacobian矩阵计算期望的关节力矩。

 虚拟力不是实际存在的作用力或力矩，机器人的运动最终是通过关节力矩实现的。为了将工作空间(Task Space)的力或力矩映射成关节空间(Joint Space)的关节力矩，需要先求得这两个空间的位置映射关系，即正运动学模型：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112239229.png|frame|none|alt=|caption image-20210419112239229]]

式中，[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112411883.png|fig:]]为机体坐标系相对于地面坐标系的 个自由度对应的位姿向量，[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112533350.png|fig:]]为'''n'''个关节变量的位置向量。进一步求'''x'''分别对'''q'''的偏导数得到：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112800061.png|frame|none|alt=|caption image-20210419112800061]]

即：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112849327.png|frame|none|alt=|caption image-20210419112849327]]

化简得到：[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419112946255.png|fig:]]，得到的雅克比矩阵将关节速度映射成机体位姿速度，不熟悉雅克比矩阵的可以参考机器人学。根据虚功原理，可以得到：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419121525072.png|frame|none|alt=|caption image-20210419121525072]]

其中，[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419121610485.png|fig:]]关节力矩列向量，[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419121700933.png|fig:]]，为外部作用力。

化简可得得到外部作用力和关节力矩之间的关系：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419121811807.png|frame|none|alt=|caption image-20210419121811807]]

在足式机器人运动控制中，常用的虚拟构件主要是弹簧与阻尼器。其本构方程为：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419121901085.png|frame|none|alt=|caption image-20210419121901085]]

其中，'''''F<sub>u</sub>'''''为虚拟构件产生的虚拟力(或力矩)， '''''K<sub>u</sub>'''''和'''''B<sub>u</sub>'''''分别为弹性和阻尼系数， '''''u<sub>d</sub>'''''为期望的实时位移，'''''u'''''为实际位移，求导即为期望速度和真实速度。虚拟力常常施加在机器人机体质心处，以控制机器人机体实现期望运动。如果要控制机器人某一点保持在期望的位置(例如质心高度控制)，则同时施加弹簧和阻尼构件；若要控制机器人达到某期望速度(例如水平移动速度控制)，则只施加阻尼构件(令 '''''K<sub>u</sub>=0''''')。

=== 3.1.2 四足机器人算法应用 ===

 传统的 VMC 应用思路——采用全局 Jacobian 矩阵将工作空间的虚拟力/力矩直接映射成所有支撑腿的主动关节力矩——具有模型推导复杂和难以实现平顺运动的缺点。

 普遍实际使用方法：分解式的 VMC 方法，对每条腿进行单独控制并只在支撑相和摆动相两种状态之间切换，从而避免了复杂的全局 Jacobian 矩阵的推导并可以减小模型切换引入的扰动，同时在支撑相和摆动相均采用 VMC 方法进行控制，使控制算法进一步简化和统一。该方法的主要思路是：将总体控制目标所施加的虚拟模型按照一定的原则分解到各个支撑腿上，利用简单的单腿Jacobian 矩阵计算得到相应的关节力矩，并且构造单腿摆动相的虚拟模型进行摆动相 VMC 控制，根据步态规则及触地信号进行模型切换，各支撑腿相互协作以实现机器人的机体的控制目标。这里以二维模型为例子做讲述。

==== 3.1.2.1 三通道解耦支撑相 ====

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419123851356.png|frame|none|alt=|caption image-20210419123851356]]

将四足机器人的控制分解为三部分：弹跳高度控制、前进速度控制和姿态控制。如上图所示采用三通道控制框架分别在机器人高度、前后和俯仰角上增加虚拟弹簧阻尼器，即构建一个PD反馈控制器。

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419132255734.png|frame|none|alt=|caption image-20210419132255734]]

其中exp为机器人期望的位置或速度，'''K'''为弹簧系数'''B'''为阻尼系数，通过调整二者能模拟出不同特性的弹簧效果。进一步可以构建如下的三通道反馈控制系统：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419132042329.png|frame|none|alt=|caption image-20210419132042329]]

与四轴飞行器一样需要将控制输出分配到驱动器上，在四轴飞行器中通过调整电机转速实现姿态控制，而四足机器人中基于作用力与反作用力调整各腿下蹬力度实现姿态、位置、速度控制。进一步，采用如下图所示的分解式VMC控制方式，将机体总体虚拟力矩输出分解到各腿中。

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419125631548.png|frame|none|alt=|caption image-20210419125631548]]

分解原理：

 (1) [[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419130843167.png|fig:]]方向：作用在质心的虚拟阻尼构件以 '''''{B}'''''为参考，分解后作用在前、后髋部的水平阻尼构件以各自的髋部坐标系'''''{H}''''' 为参考。其阻尼系数均等于分解前的一半，且均具有分解前的期望速度(，即前、后支撑腿以相同的作用力推动机器人向前运动，以保证机体平行移动；

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419132446272.png|frame|none|alt=|caption image-20210419132446272]]

 (2) '''''z''''' 方向：机体高度控制的虚拟构件分解为前、后髋部的两组虚拟弹簧-阻尼构件，并以各自的髋部坐标系 '''''{H}''''' 为参考。其弹性与阻尼系数均等于分解前的一半，且一般情况下设置前后髋部的期望高度均等于质心的期望高度。

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419132528723.png|frame|none|alt=|caption image-20210419132528723]]

同时对于机体较长那一轴来说希望机器移动时能如下图所示跟随地面角度变化而移动，因此可以在移动时设定:

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419224924866.png|frame|none|alt=|caption ]]

  (3)俯仰轴：分解后不再需要额外的虚拟弹簧-阻尼构件来调节机体倾角 。这是因为当前后两条支撑腿站定时(在确定地形上)，前后髋部的高度'''''z<sub>f</sub>'''''和'''''z<sub>h</sub>'''''决定了

θ的大小。

这样一来，分解后作用在每条腿上的虚拟力就只有沿着髋部坐标系 '''''{H}''''' 的'''''z''''' 和两个方向的虚拟力'''''f<sub>x</sub>'''''和'''''f<sub>z</sub>''''' 。在 Trot 步态中，前后两条支撑腿的合力形成了对机体的控制效果：前后髋部的'''''f<sub>z</sub>''''' 一起“支撑”机器人并维持期望高度，同时间接地调整倾角大小；前后髋部的 '''''f<sub>x</sub>'''''一起“牵引”机器人并保持期望速度。对于二维空间模型，单条腿两个主动关节恰好能和这两个虚拟力形成完整的映射关系，连接的“桥梁”正是简单的单腿 Jacobian 矩阵。

力分解后作用在单条腿上的虚拟力作用在髋部，其大小为：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133044605.png|frame|none|alt=|caption image-20210419133044605]]

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133145864.png|frame|none|alt=|caption image-20210419133145864]]

对于四足机器人二维模型，足端'''''P'''''点在髋部坐标系 '''''{H}''''' 下的正运动学模型为：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133313095.png|frame|none|alt=|caption image-20210419133313095]]

对各关节变量求偏导数得到单腿 Jacobian 矩阵为：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133333900.png|frame|none|alt=|caption image-20210419133333900]]

根据 VMC 控制原理，得到单腿支撑相的控制法则：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133439781.png|frame|none|alt=|caption image-20210419133439781]]

展开得：[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133542785.png|fig:]]

==== 3.1.2.2摆动相控制算法 ====

摆动相的虚拟模型控制思路是：将虚拟构件(弹簧-阻尼组合)一端连接到足端，另一端与足端摆动轨迹的期望点连接；当这个期望点沿着规划的轨迹移动，摆动腿的足端就会被虚拟构件产生的虚拟力“牵引”沿着这个轨迹运动。这组虚拟的弹簧-阻尼构件在二维空间中可以分解为分别沿着髋部坐标系的 轴与 轴方向的两组弹簧-阻尼构件。

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133757486.png|frame|none|alt=|caption image-20210419133757486]]

施加在足端的虚拟构件产生的虚拟力为：

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133911592.png|frame|none|alt=|caption image-20210419133911592]]

根据VMC解算原则可得到：[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419133949759.png|fig:]]

[[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419134152817.png|frame|none|alt=|caption image-20210419134152817]]

=== 3.1.3 VMC算法总结 ===

简单来说VMC的算法核心就是构建弹簧阻尼系统将施加在四足机器人上的力通过雅克比矩阵转换为关节电机力矩。对于支撑相，四足机器人的运动是由支撑相决定的，将四足机器人的运动分解为前进速度、上升高度、姿态三轴然后分解到每条腿再分解到每个关节的力矩。对于摆动相，先规划一条足端运动轨迹然后分解到X轴和Z轴，分别对这两轴构建弹簧阻尼系统然后转换为关节力矩从而实现轨迹跟随。

上面讲述的方法是基于二自由度的VMC算法，对于三自由度比如一条腿三个关节电机的情况我们需要重新计算四足机器人的正运动学，然后构建雅克比矩阵。

对于支撑相就会多一个Y方向的速度，对于摆动相，将会增加一个Y方向的轨迹，我们需要重新分解虚拟虚拟力到各个关节电机，本质思想未发生改变。

最后，关于VMC算法的仿真我还未做完，由于要准备考研等一系列事情，我对于四足的研究暂且搁置了，在后面时间空闲后我会做完并分享出来。

== 3.2 VSMC算法('''Virtual Suspension Model Control''') ==

[[File:https://www.guyuehome.com/Uploads/Editor/202103/20210327_65868.png|fig:]]<br />
VSMC其实在广义上就是VMC，只是为了描述其机械组件的特点而多添加了一个Suspension （悬挂）的意思。文章中提出使用VSMC来解决腿式机器人点足站立平衡问题，这是一种静态平衡问题，在2019年之前实现该效果的参考很少。动态平衡可以Raibert的Legged Robots That Balance一书为参考。<br />
对于VSMC的具体原理我还未做深入学习，这里给出学习资料地址。<br />
 ①腿式机器人点足站立平衡-VSMC：https://www.guyuehome.com/33275<br />
 ②VSMC论文作者B站账号地址：https://space.bilibili.com/325489396/<br />
 ③论文地址：https://journals.sagepub.com/doi/10.1177/1687814020954975<br />
 ④仿真代码：https://github.com/JameScottX/Virtual-suspension

= 四、其他 =

重要学习资料及参考论文：①：'''Legged Robots That Balance-Raibert''' ②：'''四足机器人对角小跑步态虚拟模型直觉控制-谢惠祥'''

UP主及知乎：①：'''郎崽''' ②：'''LitDynamics华北舵狗王''' ③：'''JameScottX''' ④：'''灯哥开源'''

单腿跳跃机器人仿真设计：https://zhuanlan.zhihu.com/p/97377338

[[File:https://pic1.zhimg.com/v2-527f7c0555286d0c6a933b5754ef0442_1440w.jpg?source=172ae18b|fig:]][[File:C:\Users\~~\AppData\Roaming\Typora\typora-user-images\image-20210419223404176.png|fig:]]
